package chrislo27.rhre.registry;

import chrislo27.rhre.Main;
import chrislo27.rhre.editor.Editor;
import chrislo27.rhre.inspections.InspectionPostfix;
import chrislo27.rhre.json.GameObject;
import chrislo27.rhre.util.CustomSoundUtil;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.utils.Disposable;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import ionium.animation.Animation;
import ionium.registry.handler.IAssetLoader;
import ionium.util.AssetMap;

import java.io.File;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class GameRegistry implements Disposable {

	private static GameRegistry instance;
	public final Map<String, Game> games = new LinkedHashMap<>();
	public final List<Game> gameList = new ArrayList<>();
	public final Map<Series, List<Game>> gamesBySeries = new LinkedHashMap<>();
	private final Gson gson = new GsonBuilder().setPrettyPrinting().create();

	private GameRegistry() {
	}

	public static GameRegistry instance() {
		if (instance == null) {
			instance = new GameRegistry();
			instance.init();
		}

		return instance;
	}

	public Game get(String id) {
		return games.get(id);
	}

	public SoundCue getCueRaw(String id) {
		return gameList.stream().map(g -> g.getSoundCues().stream()
				.filter(it -> it.getId().equals(id) || it.getDeprecated().contains(id)).findFirst().orElse(null))
				.filter(Objects::nonNull).findFirst().orElse(null);
	}

	public Pattern getPatternRaw(String id) {
		return gameList.stream().map(g -> g.getPatterns().stream()
				.filter(it -> it.getId().equals(id) || it.getDeprecated().contains(id)).findFirst().orElse(null))
				.filter(Objects::nonNull).findFirst().orElse(null);
	}

	private void init() {
		final long startTime = System.nanoTime();

		FileHandle gamesList = Gdx.files.internal("data/games.json");
		List<String> games = Arrays.stream(gson.fromJson(gamesList.readString("UTF-8"), String[].class))
				.collect(Collectors.toList());
		Map<Series, Integer> numberPerSeries = new HashMap<>();

		for (String gameDef : games) {
			Main.logger.info("Loading " + gameDef);
			FileHandle gameFh = Gdx.files.internal("sounds/cues/" + gameDef + "/data.json");
			GameObject gameObj = gson.fromJson(gameFh.readString("UTF-8"), GameObject.class);

			Game game;
			List<Pattern> patterns = new ArrayList<>();
			List<SoundCue> soundCues = new ArrayList<>();

			for (GameObject.SoundObject so : gameObj.cues) {
				soundCues.add(new SoundCue(so.id, so.fileExtension, so.name == null ? so.id : so.name,
						so.deprecatedIDs == null
								? new ArrayList<>()
								: Arrays.stream(so.deprecatedIDs).collect(Collectors.toList()), so.duration,
						so.canAlterPitch, so.canAlterDuration, so.introSound, so.baseBpm,
						so.loops == null ? so.canAlterDuration : ((boolean) so.loops), null));
			}

			for (GameObject.PatternObject po : gameObj.patterns) {
				Pattern p;
				List<Pattern.PatternCue> patternCues = new ArrayList<>();

				for (GameObject.PatternObject.CueObject pc : po.cues) {
					patternCues.add(new Pattern.PatternCue(pc.id, pc.beat, pc.track, pc.duration, pc.semitone));
				}

				p = new Pattern(po.id, po.name, po.isStretchable, patternCues, false, po.deprecatedIDs == null
						? new ArrayList<>()
						: Arrays.stream(po.deprecatedIDs).collect(Collectors.toList()));
				patterns.add(p);
			}

			soundCues.stream().filter(sc -> soundCues.stream().noneMatch(sc2 -> sc.getId().equals(sc2.getIntroSound
					())))
					.forEach(sc -> {
						List<Pattern.PatternCue> l = new ArrayList<>();

						l.add(new Pattern.PatternCue(sc.getId(), 0, 0, sc.getDuration(), 0));

						patterns.add(new Pattern(sc.getId() + "_AUTO-GENERATED", "cue: " + sc.getName(),
								sc.getCanAlterDuration(), l, true, new ArrayList<>()));
					});

			FileHandle iconFh = Gdx.files.internal("sounds/cues/" + gameDef + "/icon.png");

			game = new Game(gameObj.gameID, gameObj.gameName, soundCues, patterns,
					gameObj.series == null ? Series.UNKNOWN : Series.valueOf(gameObj.series.toUpperCase(Locale.ROOT)),
					iconFh.exists() ? ("sounds/cues/" + gameDef + "/icon.png") : null, false);

			if (!iconFh.exists())
				Main.logger.warn(game.getId() + " is missing icon.png");

			Main.logger.info("Loaded " + game.getId() + " with " + game.getSoundCues().size() + " cues and " +
					game.getPatterns().stream().filter(it -> !it.getAutoGenerated()).count() + " patterns");

			this.games.put(game.getId(), game);
			{
				List<Game> seriesList = this.gamesBySeries.getOrDefault(game.getSeries(), new ArrayList<>());
				seriesList.add(game);
				this.gamesBySeries.put(game.getSeries(), seriesList);
			}
			this.gameList.add(game);
			numberPerSeries.put(game.getSeries(), numberPerSeries.getOrDefault(game.getSeries(), 0) + 1);
		}

		// custom sfx
		{
			FileHandle customFolder = Gdx.files.local("customSounds/");
			if (!customFolder.exists())
				customFolder.mkdirs();

			{
				FileHandle notice = customFolder.child("README_SFX.txt");
				notice.writeString(CustomSoundUtil.getActualCustomSoundNotice(), false, "UTF-8");
			}

			Arrays.stream(customFolder.list(File::isDirectory)).forEach(fh -> {
				Main.logger.info("Loading custom folder " + fh.name());

				FileHandle[] list = fh.list((File dir, String name) -> {
					String suffix = name.lastIndexOf('.') == -1
							? (name + name.hashCode())
							: name.substring(name.lastIndexOf('.'));
					return (suffix.equalsIgnoreCase(".ogg") || suffix.equalsIgnoreCase(".mp3") ||
							suffix.equalsIgnoreCase(".wav"));
				});

				if (list.length == 0) {
					Main.logger.info("No sounds found, skipping");
					return;
				}

				Game game;
				List<Pattern> patterns = new ArrayList<>();
				List<SoundCue> soundCues = new ArrayList<>();
				FileHandle icon = fh.child("icon.png");

				Arrays.stream(list).forEach(soundFh -> {
					SoundCue sc = new SoundCue(fh.nameWithoutExtension() + "/" + soundFh.nameWithoutExtension(),
							soundFh.extension(), "custom:\n" + soundFh.nameWithoutExtension(), new ArrayList<>(),
							CustomSoundUtil.DURATION, true, true, null, 0, false, customFolder.path() + "/");
					soundCues.add(sc);
				});

				soundCues.forEach(sc -> {
					List<Pattern.PatternCue> l = new ArrayList<>();

					l.add(new Pattern.PatternCue(sc.getId(), 0, 0, sc.getDuration(), 0));

					patterns.add(
							new Pattern(sc.getId() + "_AUTO-GENERATED", "cue: " + sc.getName().replace("custom:\n",
									""),
									sc.getCanAlterDuration(), l, true, new ArrayList<>()));
				});

				game = new Game(fh.nameWithoutExtension(), fh.nameWithoutExtension(), soundCues, patterns,
						Series.CUSTOM, (icon.exists() ? icon.path() : null), true);

				Main.logger.info("Finished loading custom folder " + fh.name() + " with " + soundCues.size() + " " +
						"cues");

				this.games.put(game.getId(), game);
				{
					List<Game> seriesList = this.gamesBySeries.getOrDefault(game.getSeries(), new ArrayList<>());
					seriesList.add(game);
					this.gamesBySeries.put(game.getSeries(), seriesList);
				}
				this.gameList.add(game);
				numberPerSeries.put(game.getSeries(), numberPerSeries.getOrDefault(game.getSeries(), 0) + 1);

			});
		}

		InspectionPostfix.applyInspectionFunctions();

		// warnings
		final AtomicInteger warningCount = new AtomicInteger();
		// more than what's visible
		numberPerSeries.entrySet().stream().filter(e -> e.getValue() > Editor.ICON_COUNT_X * Editor.ICON_COUNT_Y)
				.forEach(e -> {
					Main.logger.warn("");
					Main.logger
							.warn("Series " + e.getKey().toString() + " has " + e.getValue() + " games, maximum is " +
									(Editor.ICON_COUNT_X * Editor.ICON_COUNT_Y));
					Main.logger.warn("");
					warningCount.getAndIncrement();
				});
		// missing sound cues for patterns
		this.gameList.forEach(game -> game.getPatterns().forEach(pattern -> pattern.getCues().forEach(patternCue -> {
			if (this.gameList.stream()
					.noneMatch(g -> g.getSoundCues().stream().anyMatch(sc -> patternCue.getId().equals(sc.getId())))) {
				Main.logger.warn("Pattern " + pattern.getId() + " has a pattern cue " + patternCue.getId() +
						" with no matching sound cue");
				warningCount.getAndIncrement();
			}
		})));

		Main.logger.info("Loaded " + this.games.size() + " games with " + warningCount.get() + " warning(s), took " +
				((System.nanoTime() - startTime) / 1_000_000.0) + " ms");
	}

	public CueAssetLoader getAssetLoader() {
		return new CueAssetLoader();
	}

	@Override
	public void dispose() {
		GameRegistry.instance().games.values().forEach(g -> g.getSoundCues().forEach(sc -> {
//			sc.getAlMusic().dispose();
		}));
	}

	public static class CueAssetLoader implements IAssetLoader {

		private CueAssetLoader() {

		}

		@Override
		public void addManagedAssets(AssetManager manager) {
			GameRegistry.instance().games.values().forEach(g -> g.getSoundCues().forEach(sc -> {
				String path = (sc.getSoundFolder() == null ? "sounds/cues/" : sc.getSoundFolder()) + sc.getId() + "." +
						sc.getFileExtension();
				manager.load(AssetMap.add("soundCue_" + sc.getId(),
						path), Sound.class);
//				sc.loadALMusic(path);
			}));
			GameRegistry.instance().games.values().forEach(g -> manager.load(AssetMap.add("gameIcon_" + g.getId(),
					g.getIcon() == null
							? ("images/missing_game_icon.png")
							: (g.getIconIsRawPath() ? g.getIcon() : ("sounds/cues/" + g.getId() + "/icon.png"))),
					Texture.class));
		}

		@Override
		public void addUnmanagedTextures(HashMap<String, Texture> textures) {

		}

		@Override
		public void addUnmanagedAnimations(HashMap<String, Animation> animations) {

		}
	}

}
